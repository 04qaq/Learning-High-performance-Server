### 线程同步原语：Condition Variable (条件变量)

**核心作用**：线程间等待/通知机制，**避免忙等**（busy-wait）。  
**关键前提**：必须与 `std::mutex` + `std::unique_lock` 配合使用（**不可独立使用**）。

#### **核心 API**
```cpp
// 1. 基础等待（阻塞直到被唤醒）
void wait(std::unique_lock<std::mutex>& lock);

// 2. 带谓词的等待（自动循环检查条件，避免虚假唤醒）
template<typename Predicate>
void wait(std::unique_lock<std::mutex>& lock, Predicate pred);

// 3. 带超时的等待（相对时间）
std::cv_status wait_for(
    std::unique_lock<std::mutex>& lock, 
    std::chrono::duration<Rep, Period> rel_time
);

// 4. 带超时和谓词的等待
template<typename Predicate>
bool wait_for(
    std::unique_lock<std::mutex>& lock, 
    std::chrono::duration<Rep, Period> rel_time, 
    Predicate pred
);

// 5. 绝对时间版（同上，用 std::chrono::time_point）
std::cv_status wait_until(...);
template<typename Predicate> bool wait_until(..., Predicate pred);
```

#### **通知操作**
```cpp
void notify_one();  // 随机唤醒一个等待线程
void notify_all();  // 唤醒所有等待线程
```

#### **关键使用原则**
1. **必须用 `unique_lock`**：`condition_variable` 依赖 `unique_lock` 的锁状态。
2. **谓词模式（推荐）**：  
   
   ```cpp
   std::mutex mtx;
   std::condition_variable cv;
   bool ready = false;
   
   // 等待线程
   {
       std::unique_lock lock(mtx);
       cv.wait(lock, [&] { return ready; }); // 自动循环检查，避免虚假唤醒
       // 条件满足后执行
   }
   ```
   >  错误：`wait(lock)` 后直接使用条件（可能因虚假唤醒导致逻辑错误）  
   >  正确：**始终用谓词 `wait(lock, pred)`**
   
3. **通知时机**：  
   
   - 修改共享状态（如 `ready = true`）**必须在锁内**。
   - 通知（`notify_*`）**必须在锁内或锁外**（但需确保状态修改在通知前完成）。

---

### **互斥锁 (Mutex) 与 RAII 包装**
#### **基础互斥类型**
| 类型                        | 特性                         | 适用场景               | 关键 API                                     |
| --------------------------- | ---------------------------- | ---------------------- | -------------------------------------------- |
| `std::mutex`                | 基础互斥，非递归，无共享读写 | 通用临界区             | `lock()`, `try_lock()`, `unlock()`           |
| `std::recursive_mutex`      | 递归锁（同一线程可多次加锁） | 递归函数需加锁         | `lock()`, `unlock()`（同 `mutex`）           |
| `std::timed_mutex`          | 支持超时锁                   | 需超时等待的场景       | `try_lock_for()`, `try_lock_until()`         |
| `std::shared_mutex` (C++17) | 读写锁（允许多读独写）       | 读多写少场景（如缓存） | `lock_shared()`, `unlock_shared()`, `lock()` |

> **重要提示**：
>
> - `std::recursive_mutex` **应避免使用**（掩盖设计问题，性能略差）。
> - `std::spinlock` **标准库未提供**（需自旋实现，适合极短临界区）。
> - **所有互斥量必须用 RAII 包装**（`lock_guard`/`unique_lock`）。

---

#### **RAII 锁包装（推荐使用）**
| 类型                       | 特性                         | 适用场景                    |
| -------------------------- | ---------------------------- | --------------------------- |
| `std::lock_guard`          | 简单自动锁/解锁              | 临界区短、无需 `wait()`     |
| `std::unique_lock`         | 灵活（支持延迟锁/解锁/转移） | 需配合 `condition_variable` |
| `std::shared_lock`         | 读锁 RAII                    | `shared_mutex` 的读操作     |
| `std::scoped_lock` (C++17) | 安全锁定多个互斥量           | 避免多锁死锁                |

**安全获取多锁示例**：

```cpp
// 安全方式（避免死锁）
std::scoped_lock lock(mtx1, mtx2); // 内部原子尝试锁定

// 危险方式（可能死锁）
mtx1.lock(); mtx2.lock(); // 未保证顺序
```

---

### **条件变量与互斥的正确配合**
```cpp
std::mutex mtx;
std::condition_variable cv;
bool data_ready = false;

// 生产者线程
{
    std::lock_guard lock(mtx);
    data_ready = true;
    cv.notify_one(); // 通知等待线程
}

// 消费者线程
{
    std::unique_lock lock(mtx);
    cv.wait(lock, [&]{ return data_ready; }); // 必须用谓词！
    // 安全使用 data_ready
}
```

>  **核心原则**：  
> **修改状态 → 通知 → 等待线程用谓词检查**。  
> 未用谓词会导致虚假唤醒（`notify` 时条件未满足）。

---

### **原子操作 (std::atomic)**
**核心作用**：**无锁同步**，避免互斥开销（适用于计数器、标志等简单场景）。

#### **关键特性**
| 特性                        | 说明                             |
| --------------------------- | -------------------------------- |
| `is_lock_free()`            | 检查是否硬件原子操作（非锁实现） |
| `memory_order`              | 控制内存可见性（关键！）         |
| `wait()`/`notify()` (C++20) | 高效阻塞等待（类似 futex）       |

#### **内存序 (memory_order) - 重点**
| 模式                | 用途                       | 安全性                   |
| ------------------- | -------------------------- | ------------------------ |
| `seq_cst` (默认)    | 全序一致（最安全）         | ✅ 推荐新手使用           |
| `release`/`acquire` | 发布-订阅模式（高性能）    | ✅ 读写场景               |
| `relaxed`           | 仅保证原子性（不保证顺序） | ⚠️ 仅用于计数器等简单场景 |

**典型用例：发布-订阅（发布指针）**
```cpp
std::atomic<Data*> ptr{nullptr};
Data* data = new Data{42};

// 生产者（写端）
data->x = 100;
ptr.store(data, std::memory_order_release); // 发布

// 消费者（读端）
Data* p = ptr.load(std::memory_order_acquire); // 订阅
if (p) std::cout << p->x; // 安全看到 100
```
> ❌ 错误：用 `relaxed` 替代 `release`/`acquire` → 消费者可能看不到 `data->x=100`。

---

#### **CAS 循环（无锁数据结构）**
```cpp
std::atomic<Node*> head{nullptr};

void push(Node* node) {
    node->next = head.load(std::memory_order_relaxed);
    while (!head.compare_exchange_weak(
        node->next, 
        node,
        std::memory_order_release, 
        std::memory_order_relaxed
    )) {
        // 虚假失败时重试（compare_exchange_weak 允许）
    }
}
```
> ⚠️ **注意**：  
> - `weak` 允许虚假失败（适合循环）  
> - `strong` 无虚假失败（适合单次尝试）

---

### **常见误区与避坑指南**
| 误区                               | 正确做法                                              |
| ---------------------------------- | ----------------------------------------------------- |
| 用 `wait(lock)` 而不加谓词         | **必须用 `wait(lock, pred)`**                         |
| 在 `notify` 后直接检查条件         | **条件修改必须在锁内**，`notify` 在锁内/外均可        |
| 用 `std::recursive_mutex` 代替设计 | **优先重构逻辑**（避免递归锁）                        |
| 用 `relaxed` 内存序做复杂同步      | **仅用于计数器/标志**，复杂场景用 `release`/`acquire` |
| 混淆 `shared_mutex` 的读写锁       | **读操作用 `shared_lock`，写操作用 `unique_lock`**    |

---

### **总结：选择建议**
| 场景               | 推荐方案                                                     |
| ------------------ | ------------------------------------------------------------ |
| 通用临界区         | `std::mutex` + `std::lock_guard`                             |
| 读多写少           | `std::shared_mutex` + `std::shared_lock`（写用 `unique_lock`） |
| 等待条件（非忙等） | `std::condition_variable` + `std::unique_lock`（**必须用谓词**） |
| 简单计数器/标志    | `std::atomic<T>`（默认 `seq_cst`）                           |
| 高性能无锁结构     | `std::atomic` + `CAS` + `release`/`acquire`                  |

> **核心原则**：  
> **优先用 RAII 包装锁 → 用谓词避免虚假唤醒 → 用内存序保证可见性**。

